<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Clash Gemini: Mobile Responsive</title>
    <style>
        /* --- VIEWPORT & SCALING SETUP --- */
        body { 
            margin: 0; 
            background: #111; 
            overflow: hidden; 
            font-family: 'Segoe UI', sans-serif; 
            color: white; 
            user-select: none;
            /* Center the game container */
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
            width: 100vw;
            touch-action: none; /* Prevent mobile scrolling */
        }

        /* The Game Container holds everything and is scaled via JS */
        #game-container {
            position: relative;
            width: 400px;
            height: 700px;
            background: #222;
            overflow: hidden;
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
        }

        /* --- EXISTING STYLES (Adapted) --- */
        #gameCanvas { 
            display: block; 
            background: #2a2; 
            border-left: 5px solid #151; 
            border-right: 5px solid #151; 
            cursor: crosshair; 
        }
        
        #ui-container { position: absolute; bottom: 5px; width: 100%; display: flex; flex-direction: column; align-items: center; pointer-events: none; transition: opacity 0.5s; z-index: 10; }
        
        .elixir-wrapper { position: relative; width: 320px; height: 25px; background: #222; border-radius: 15px; border: 3px solid #000; margin-bottom: 8px; pointer-events: auto; box-shadow: 0 4px 8px rgba(0,0,0,0.5); overflow: hidden; }
        .elixir-fill { height: 100%; background: linear-gradient(180deg, #d000d0, #900090); width: 50%; box-shadow: inset 0 2px 5px rgba(255,255,255,0.3); transition: width 0.1s linear; }
        .elixir-fill.boosted { background: linear-gradient(180deg, #ff00ff, #aa00aa); box-shadow: 0 0 15px #ff00ff; animation: pulse 0.5s infinite; }
        .elixir-fill.double-elixir { animation: rainbow 2s linear infinite; }
        @keyframes rainbow { 0% { filter: hue-rotate(0deg); } 100% { filter: hue-rotate(360deg); } }
        @keyframes pulse { 0% { opacity: 0.8; } 50% { opacity: 1; } 100% { opacity: 0.8; } }
        .elixir-text { position: absolute; top: 0; left: 0; width: 100%; height: 100%; text-align: center; line-height: 25px; font-weight: 800; font-size: 16px; text-shadow: 1px 1px 2px #000; color: #fff; z-index: 2; }

        #deck-area { display: flex; align-items: flex-end; gap: 15px; pointer-events: auto; }
        #hand { display: flex; gap: 8px; }
        #next-card-slot { display: flex; flex-direction: column; align-items: center; margin-left: 10px; opacity: 0.9; transform: scale(0.85); background: rgba(0,0,0,0.4); padding: 5px; border-radius: 8px; border: 1px solid #555;}
        .next-label { font-size: 10px; font-weight: bold; margin-bottom: 2px; color: #ddd; text-transform: uppercase; letter-spacing: 1px; }

        .card { 
            width: 70px; height: 96px; background: linear-gradient(135deg, #eee, #ccc); color: #000; 
            border-radius: 6px; border: 2px solid #444; cursor: pointer; 
            position: relative; top: 0; transition: all 0.1s;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            text-align: center; box-shadow: 0 4px 0 #222;
        }
        .card:hover { transform: translateY(-4px); border-color: #fff; }
        .card.selected { border-color: #00ff00; background: #dbffdb; transform: translateY(-15px); box-shadow: 0 15px 20px rgba(0,0,0,0.5); z-index: 10; }
        .card.mirror-card { border-color: #d000d0; background: linear-gradient(135deg, #fdf, #d0d); }
        .card.disabled { opacity: 0.5; cursor: not-allowed; filter: grayscale(100%); }
        .card h3 { font-size: 10px; margin: 4px 0; font-weight: 800; text-transform: uppercase; }
        .card p { font-size: 14px; margin: 0; font-weight: 900; color: #b000b0; text-shadow: 1px 1px 0 #fff; }
        .card-icon { width: 36px; height: 36px; border-radius: 50%; margin-bottom: 2px; border: 2px solid #000; box-shadow: inset 0 0 5px rgba(0,0,0,0.5); }
        .card-type { font-size: 8px; color: #555; margin-top: 1px; text-transform: uppercase; font-weight: bold; }

        .screen-overlay { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            background: rgba(0,0,0,0.9); display: flex; flex-direction: column; 
            align-items: center; justify-content: center; z-index: 1000; 
        }
        #main-menu h1 { font-size: 70px; color: #4488ff; text-shadow: 0 5px 0 #002266, 0 0 30px #0044aa; margin-bottom: 5px; letter-spacing: 2px; font-style: italic; white-space: nowrap; transform: scale(0.8); }
        #main-menu h2 { font-size: 24px; color: #ddd; margin-bottom: 50px; font-weight: 300; letter-spacing: 5px; }
        #end-screen { display: none; }
        #end-message { font-size: 60px; font-weight: 900; text-shadow: 4px 4px 0 #000; text-transform: uppercase; margin-bottom: 20px; text-align:center;}
        
        #deck-builder { display: none; padding-top: 20px; justify-content: flex-start; }
        .deck-slots { display: flex; gap: 10px; margin-bottom: 20px; padding: 15px; background: rgba(255,255,255,0.05); border-radius: 10px; min-height: 100px; align-items: center; border: 1px solid #444; width: 90%; justify-content: center; flex-wrap: wrap;}
        .slot { width: 70px; height: 90px; border: 2px dashed #666; border-radius: 6px; display: flex; align-items: center; justify-content: center; opacity: 0.5; color: #888; font-size: 12px; }
        .collection-grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 5px; width: 95%; overflow-y: auto; max-height: 350px; padding: 5px;}
        .card-mini { transform: scale(0.85); margin:0; }
        .card-mini.in-deck { opacity: 0.3; border-color: #444; background: #999; }

        #btn-row { display: flex; gap: 20px; margin-top: 10px; }
        .btn {
            background: linear-gradient(180deg, #ffcc00, #ffaa00); border: none; border-bottom: 5px solid #b38f00; border-radius: 8px;
            padding: 15px 40px; font-size: 22px; font-weight: 900; cursor: pointer;
            color: #333; text-shadow: 0 1px 0 rgba(255,255,255,0.4); text-transform: uppercase; transition: transform 0.1s;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        }
        .btn:active { transform: translateY(4px); border-bottom: 1px solid #b38f00; box-shadow: none; }
        .btn:hover { filter: brightness(1.1); }
        .btn-menu { background: linear-gradient(180deg, #4488ff, #0055aa); border-bottom: 5px solid #003366; color: white; text-shadow: 0 1px 2px black; }
        .btn-green { background: linear-gradient(180deg, #44ff44, #00aa00); border-bottom: 5px solid #006600; color: #003300; }
        .btn:disabled { background: #555; border-bottom: 5px solid #333; color: #888; cursor: not-allowed; transform: none; filter: none; }

        .error-zone { position: absolute; top: 0; left: 50%; transform: translateX(-50%); width: 400px; height: 340px; background: rgba(255, 0, 0, 0.3); display: none; pointer-events: none; z-index: 50; border-bottom: 2px solid rgba(255,0,0,0.5); }
        #debug-console { position: absolute; top: 0; left: 0; color: yellow; background: rgba(0,0,0,0.5); font-size: 12px; pointer-events: none; max-width: 300px; z-index: 9999;}
    </style>
</head>
<body>

<div id="game-container">
    <div class="error-zone" id="errorZone"></div>
    <canvas id="gameCanvas" width="400" height="700"></canvas>

    <div id="main-menu" class="screen-overlay">
        <h1>CLASH GEMINI</h1>
        <h2>STRATEGY ENGINE</h2>
        <div id="btn-row">
            <button class="btn" onclick="startGame()">START BATTLE</button>
            <button class="btn btn-menu" onclick="openDeckBuilder()">EDIT DECK</button>
        </div>
    </div>

    <div id="deck-builder" class="screen-overlay">
        <h2 style="color:white; margin-bottom:5px">YOUR DECK <span id="deck-count" style="color:#4488ff">(0/8)</span></h2>
        <div class="deck-slots" id="builder-slots"></div>
        <h2 style="color:white; margin-bottom:5px">COLLECTION</h2>
        <div class="collection-grid" id="builder-collection"></div>
        <div id="btn-row">
            <button class="btn btn-green" id="save-deck-btn" onclick="saveDeck()" disabled>SAVE & BACK</button>
        </div>
    </div>

    <div id="end-screen" class="screen-overlay">
        <div id="end-message"></div>
        <div id="btn-row">
            <button class="btn" onclick="resetGame()">PLAY AGAIN</button>
            <button class="btn btn-menu" onclick="goToMenu()">MAIN MENU</button>
        </div>
    </div>

    <div id="debug-console"></div>

    <div id="ui-container" style="display:none;">
        <div class="elixir-wrapper">
            <div class="elixir-text" id="elixirText">5</div>
            <div class="elixir-fill" id="elixirFill"></div>
        </div>
        
        <div id="deck-area">
            <div id="hand"></div>
            <div id="next-card-slot">
                <span class="next-label">NEXT</span>
                <div id="next-card-container"></div>
            </div>
        </div>
    </div>
</div>

<script>
const container = document.getElementById('game-container');
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// --- RESPONSIVE SCALING LOGIC ---
function fitToScreen() {
    const aspect = 400 / 700;
    const winW = window.innerWidth;
    const winH = window.innerHeight;
    const winAspect = winW / winH;
    
    let scale;
    if (winAspect < aspect) {
        // Window is taller than game aspect, constrain by width
        scale = winW / 400;
    } else {
        // Window is wider than game aspect, constrain by height
        scale = winH / 700;
    }
    
    // Cap scale to avoid pixelation on huge screens, or let it grow if you prefer
    // scale = Math.min(scale, 1.5); 
    
    container.style.transform = `scale(${scale})`;
}
window.addEventListener('resize', fitToScreen);
fitToScreen(); // Call once on load

// --- INPUT HANDLING (Updated for Scale) ---
let mouseX = 0, mouseY = 0;

function getScaledPos(clientX, clientY) {
    const rect = canvas.getBoundingClientRect();
    // Map visual coordinates back to internal 400x700 resolution
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    return {
        x: (clientX - rect.left) * scaleX,
        y: (clientY - rect.top) * scaleY
    };
}

// Mouse
window.addEventListener('mousemove', e => {
    const pos = getScaledPos(e.clientX, e.clientY);
    mouseX = pos.x;
    mouseY = pos.y;
});

// Touch (Mobile support)
window.addEventListener('touchstart', e => {
    if(e.target === canvas) e.preventDefault();
    if(e.touches.length > 0) {
        const pos = getScaledPos(e.touches[0].clientX, e.touches[0].clientY);
        mouseX = pos.x;
        mouseY = pos.y;
        // Trigger click logic
        handleInputStart(pos.x, pos.y);
    }
}, {passive: false});

// Existing click listener replaced by generic handler
window.addEventListener('mousedown', (e) => {
    const pos = getScaledPos(e.clientX, e.clientY);
    handleInputStart(pos.x, pos.y);
});

function safeLoop(callback) {
    try { callback(); } catch (e) { console.error(e); document.getElementById('debug-console').innerText = "ERROR: " + e.message; }
}

const MAX_ELIXIR = 10;
const RIVER_Y_TOP = 335;
const RIVER_Y_BOTTOM = 365;
const ELIXIR_RATE = 0.65;
const AGGRO_RANGE = 250;
const DOUBLE_ELIXIR_TIME = 60; // 1 Min
const TIME_LIMIT_NORMAL = 180; // 3 Minutes
const TIME_LIMIT_MAX = 300;    // 5 Minutes

const UNIT_TYPES = [
    /* 0 */ { name: 'Goblins',   type:'troop', cost: 2, count: 3, hp: 80,  dmg: 50, speed: 70, range: 25, color: '#33cc33', radius: 8, hitAir: false, flying: false },
    /* 1 */ { name: 'Knight',    type:'troop', cost: 3, count: 1, hp: 700, dmg: 75, speed: 45, range: 30, color: '#4488ff', radius: 14, hitAir: false, flying: false },
    /* 2 */ { name: 'Archers',   type:'troop', cost: 3, count: 2, hp: 250, dmg: 55, speed: 55, range: 140, color: '#ffee00', radius: 10, hitAir: true, flying: false, projectile: true },
    /* 3 */ { name: 'Wizard',    type:'troop', cost: 5, count: 1, hp: 350, dmg: 130,speed: 45, range: 150, color: '#aa00ff', radius: 13, hitAir: true, flying: false, projectile: true, splash: true },
    /* 4 */ { name: 'Giant',     type:'troop', cost: 5, count: 1, hp: 2000,dmg: 120,speed: 25, range: 30, color: '#ff8844', radius: 22, hitAir: false, flying: false, targetBuilding: true },
    /* 5 */ { name: 'PEKKA',     type:'troop', cost: 7, count: 1, hp: 2400,dmg: 350,speed: 25, range: 30, color: '#555566', radius: 24, hitAir: false, flying: false },
    /* 6 */ { name: 'Minions',   type:'troop', cost: 3, count: 3, hp: 90,  dmg: 50, speed: 80, range: 30, color: '#88ccff', radius: 8,  hitAir: true, flying: true },
    /* 7 */ { name: 'Baby Drag', type:'troop', cost: 4, count: 1, hp: 800, dmg: 100,speed: 50, range: 100,color: '#00aa44', radius: 18, hitAir: true, flying: true, projectile: true, splash: true },
    /* 8 */ { name: 'Musketeer', type:'troop', cost: 4, count: 1, hp: 340, dmg: 100,speed: 45, range: 160,color: '#aa4488', radius: 12, hitAir: true, flying: false, projectile: true },
    /* 9 */ { name: 'Cannon',    type:'building', cost: 3, hp: 400, dmg: 80, range: 160, color: '#333333', radius: 20, hitAir: false, lifetime: 20, projectile: true, speed: 0 },
    /* 10 */{ name: 'Goblin Hut',type:'building', cost: 5, hp: 600, dmg: 0,  range: 0,   color: '#664422', radius: 20, hitAir: false, lifetime: 30, spawnUnit: 14, speed: 0 },
    /* 11 */{ name: 'Skarmy',    type:'troop', cost: 3, count: 8, hp: 50, dmg: 40, speed: 60, range: 25, color: '#eeeeee', radius: 6, hitAir: false, flying: false },
    /* 12 */{ name: 'Fireball',  type:'spell', cost: 4, dmg: 325, radius: 60, color: '#ff6600' },
    /* 13 */{ name: 'Zap',       type:'spell', cost: 2, dmg: 80,  radius: 40, color: '#00ffff' },
    /* 14 */{ name: 'Spear Gob', type:'troop', cost: 0, hp: 50, dmg: 30, speed: 65, range: 130, color: '#55dd55', radius: 6, hitAir: true, flying: false, projectile: true },
    /* 15 */{ name: 'Rocket',    type:'spell', cost: 7, dmg: 9999, radius: 60, color: '#aa4444' }, 
    /* 16 */{ name: 'Mirror',    type:'special', cost: 0, color: '#d0d0d0' },
    /* 17 */{ name: 'Pump',      type:'building', cost: 7, hp: 600, lifetime: 40, dmg: 0, range: 0, radius: 15, color: '#aa00aa', hitAir: false, flying: false, speed: 0 },
    /* 18 */{ name: 'Barbarians',type:'troop', cost: 5, count: 5, hp: 300, dmg: 70, speed: 50, range: 25, color: '#ffbb00', radius: 10, hitAir: false, flying: false },
    /* 19 */{ name: 'The Log',   type:'spell', cost: 2, dmg: 100, radius: 40, color: '#8b4513' },
    /* 20 */{ name: 'Freeze',    type:'spell', cost: 4, dmg: 95,  radius: 80, color: '#aaddff' },
    /* 21 */{ name: 'Royal Recruits',type:'troop', cost: 6, count: 6, hp: 450, dmg: 75, speed: 45, range: 35, color: '#606060', radius: 12, hitAir: false, flying: false, formation:'line' },
    /* 22 */{ name: 'Royal Delivery',type:'spell', cost: 3, dmg: 350, radius: 60, color: '#664422', spawnUnit: 23 }, 
    /* 23 */{ name: 'Royal Recruit', type:'troop', cost: 0, hp: 450, dmg: 75, speed: 45, range: 35, color: '#606060', radius: 12, hitAir: false, flying: false },
    /* 24 */{ name: 'Goblin Barrel', type:'spell', cost: 3, dmg: 0, radius: 0, color: '#336600', spawnUnit: 0 }
];

const DRAFTABLE_INDICES = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,15,16,17,18,19,20,21,22,24];
const PUMP_INDEX = 17;

let playerDeck = [1, 2, 3, 4, 12, 13, 24, 19]; 

let gameState = 'MENU';
let gameTime = 0;
let lastTime = 0;
let entities = [];
let projectiles = [];
let particles = [];
let player = { elixir: 5, team: 'blue' };
let enemy = { elixir: 5, team: 'red', nextCard: null, waitTime: 0 };
let leftEnemyTowerDead = false;
let rightEnemyTowerDead = false;
let overtimeTriggered = false;
let deckQueue = [];
let hand = [];
let selectedHandIndex = null;
let lastPlayedCardIdx = null;

// --- DRAWING & UTILS ---
function drawMap() {
    for (let r = 0; r < 20; r++) {
        for (let c = 0; c < 10; c++) {
            ctx.fillStyle = (r + c) % 2 === 0 ? '#4da34d' : '#3da33d';
            ctx.fillRect(c * 40, r * 35, 40, 35);
        }
    }
    
    ctx.fillStyle = '#4488ff';
    ctx.fillRect(0, RIVER_Y_TOP, 400, 30);
    ctx.fillStyle = 'rgba(255,255,255,0.1)';
    ctx.beginPath();
    ctx.moveTo(0, 345); ctx.lineTo(400, 345);
    ctx.moveTo(0, 355); ctx.lineTo(400, 355);
    ctx.stroke();

    ctx.fillStyle = '#8b5a2b';
    ctx.fillRect(80, RIVER_Y_TOP - 5, 40, 40); 
    ctx.fillRect(280, RIVER_Y_TOP - 5, 40, 40);
    ctx.fillStyle = '#654321';
    for(let i=0; i<8; i++) {
        ctx.fillRect(80, RIVER_Y_TOP - 5 + i*5, 40, 2);
        ctx.fillRect(280, RIVER_Y_TOP - 5 + i*5, 40, 2);
    }
}

function drawTower(e) {
    const isKing = (e.role === 'king');
    ctx.fillStyle = e.color === '#0044aa' ? '#3366cc' : '#cc3333';
    ctx.shadowColor = 'rgba(0,0,0,0.5)';
    ctx.shadowBlur = 10;
    ctx.fillRect(e.x - 20, e.y - 20, 40, 40);
    ctx.fillStyle = 'rgba(0,0,0,0.2)';
    ctx.fillRect(e.x - 15, e.y - 15, 30, 30);
    ctx.fillStyle = e.color === '#0044aa' ? '#5588ff' : '#ff5555';
    ctx.fillRect(e.x - 15, e.y - 25, 30, 20);
    
    if (isKing) {
        ctx.fillStyle = 'gold';
        ctx.beginPath();
        ctx.moveTo(e.x-10, e.y-30);
        ctx.lineTo(e.x, e.y-40);
        ctx.lineTo(e.x+10, e.y-30);
        ctx.fill();
        
        if (!e.active) {
            ctx.fillStyle = '#fff';
            ctx.font = "12px sans-serif";
            ctx.fillText("Zzz", e.x + 10, e.y - 40);
        }
    }
    ctx.shadowBlur = 0;
    ctx.lineWidth = 2;
    ctx.strokeStyle = '#222';
    ctx.strokeRect(e.x - 20, e.y - 20, 40, 40);
    
    if (e.frozenTimer > 0) {
        ctx.fillStyle = 'rgba(0, 255, 255, 0.5)';
        ctx.fillRect(e.x - 22, e.y - 25, 44, 48);
    }
}

// ... Deck Builder Functions ...
function openDeckBuilder() { document.getElementById('main-menu').style.display = 'none'; document.getElementById('deck-builder').style.display = 'flex'; renderBuilder(); }
function saveDeck() { if (playerDeck.length !== 8) return; document.getElementById('deck-builder').style.display = 'none'; document.getElementById('main-menu').style.display = 'flex'; }
function toggleDeckCard(idx) { const existingPos = playerDeck.indexOf(idx); if (existingPos > -1) playerDeck.splice(existingPos, 1); else if (playerDeck.length < 8) playerDeck.push(idx); renderBuilder(); }
function renderBuilder() {
    const slotsDiv = document.getElementById('builder-slots');
    const collDiv = document.getElementById('builder-collection');
    const countSpan = document.getElementById('deck-count');
    const saveBtn = document.getElementById('save-deck-btn');
    slotsDiv.innerHTML = '';
    for(let i=0; i<8; i++) {
        if (i < playerDeck.length) {
            const u = UNIT_TYPES[playerDeck[i]];
            slotsDiv.innerHTML += `<div class="card card-mini" onclick="toggleDeckCard(${playerDeck[i]})"><div class="card-icon" style="background:${u.color}"></div><h3>${u.name}</h3></div>`;
        } else { slotsDiv.innerHTML += `<div class="slot">Empty</div>`; }
    }
    collDiv.innerHTML = '';
    DRAFTABLE_INDICES.forEach(idx => {
        const u = UNIT_TYPES[idx];
        const inDeck = playerDeck.includes(idx);
        collDiv.innerHTML += `<div class="card card-mini ${inDeck ? 'in-deck' : ''}" onclick="toggleDeckCard(${idx})"><div class="card-icon" style="background:${u.color}"></div><h3>${u.name}</h3><p>${u.cost}</p></div>`;
    });
    countSpan.innerText = `(${playerDeck.length}/8)`;
    saveBtn.disabled = (playerDeck.length !== 8);
}

// --- ENTITY ---
class Entity {
    constructor(x, y, team, typeIdx, role = null) {
        this.x = x || 0; this.y = y || 0; this.team = team; this.typeIdx = typeIdx;
        this.spawnTimer = 0; this.role = role; this.frozenTimer = 0;

        if (typeIdx === 'tower') {
            const isKing = (role === 'king');
            this.hp = isKing ? 4000 : 2500; this.maxHp = this.hp; this.dmg = isKing ? 90 : 70;
            this.range = isKing ? 170 : 190; this.radius = isKing ? 40 : 30; this.speed = 0;
            this.color = team === 'blue' ? '#0044aa' : '#cc0000';
            this.attackSpeed = isKing ? 1400 : 1000;
            this.projectile = true; this.hitAir = true; this.flying = false; this.type = 'building';
            this.lifetime = 0; this.spawnUnit = null;
            this.active = !isKing; 
        } else {
            const stats = UNIT_TYPES[typeIdx];
            this.hp = stats.hp; this.maxHp = stats.hp; this.dmg = stats.dmg;
            this.range = stats.range; this.radius = stats.radius; this.speed = stats.speed || 0;
            this.color = team === 'blue' ? stats.color : '#ff4444'; 
            if (stats.name.includes('Gob') && team === 'red') this.color = '#115511';
            
            this.attackSpeed = stats.attackSpeed || 1000; this.projectile = stats.projectile || false;
            this.targetBuilding = stats.targetBuilding || false; this.splash = stats.splash || false;
            this.hitAir = stats.hitAir || false; this.flying = stats.flying || false;
            this.lifetime = stats.lifetime || 0; this.spawnUnit = (stats.spawnUnit !== undefined) ? stats.spawnUnit : null;
            this.type = stats.type || 'troop';
        }
        this.lastAttackTime = 0; this.dead = false; this.target = null;
    }

    update(dt) {
        if (this.dead) return;
        if (this.frozenTimer > 0) { this.frozenTimer -= dt; return; }
        if (this.typeIdx === 'tower' && !this.active) return; 

        if (this.lifetime > 0) { this.hp -= (this.maxHp / this.lifetime) * dt; if (this.hp <= 0) { this.die(); return; } }
        if (this.spawnUnit !== null) {
            this.spawnTimer += dt;
            if (this.spawnTimer > 4.5) {
                this.spawnTimer = 0;
                entities.push(new Entity(this.x, this.y, this.team, this.spawnUnit));
                spawnParticle(this.x, this.y, 'lime', 2);
            }
        }
        if (!this.target || this.target.dead || !this.inRange(this.target)) this.target = this.findTarget();
        if (this.target && this.inRange(this.target)) {
            if (Date.now() - this.lastAttackTime > this.attackSpeed) {
                this.attack(this.target); this.lastAttackTime = Date.now();
            }
        } else if (this.speed > 0) this.move(dt);
    }

    die() {
        if (this.dead) return;
        this.dead = true;
        if (this.typeIdx === 10) {
            const count = Math.random() > 0.5 ? 3 : 2;
            for(let i=0; i<count; i++) entities.push(new Entity(this.x + (Math.random()-0.5)*20, this.y + (Math.random()-0.5)*20, this.team, 14));
            spawnParticle(this.x, this.y, 'lime', 10);
        }
        if (this.typeIdx === 'tower' && this.role !== 'king') {
            const king = entities.find(e => e.team === this.team && e.role === 'king');
            if (king) king.active = true;
            if (this.team === 'red') {
                if (this.role === 'left_tower') leftEnemyTowerDead = true;
                if (this.role === 'right_tower') rightEnemyTowerDead = true;
            }
        }
        if (this.role === 'king') checkWin(this.team);
    }

    takeDamage(amount) {
        this.hp -= amount;
        if (this.role === 'king' && !this.active) this.active = true;
        spawnParticle(this.x, this.y, 'white', 1);
        if (this.hp <= 0) this.die();
    }

    move(dt) {
        if (!this.flying) {
            const inRiverY = (this.y > RIVER_Y_TOP && this.y < RIVER_Y_BOTTOM);
            if (inRiverY) {
                const onLeftBridge = (this.x > 80 && this.x < 120);
                const onRightBridge = (this.x > 280 && this.x < 320);
                if (!onLeftBridge && !onRightBridge) {
                    if (Math.abs(this.y - RIVER_Y_TOP) < Math.abs(this.y - RIVER_Y_BOTTOM)) {
                        this.y = RIVER_Y_TOP - 1; 
                    } else {
                        this.y = RIVER_Y_BOTTOM + 1;
                    }
                }
            }
        }

        let destX = this.x; let destY = this.y;
        if (this.target) { destX = this.target.x; destY = this.target.y; } 
        else {
            let towerTarget = null; let minDist = Infinity;
            entities.forEach(e => {
                if (e.team !== this.team && (e.typeIdx === 'tower' || e.type === 'building') && !e.dead) {
                    const d = Math.hypot(e.x - this.x, e.y - this.y);
                    if (d < minDist) { minDist = d; towerTarget = e; }
                }
            });
            if (towerTarget) { destX = towerTarget.x; destY = towerTarget.y; } 
            else { destY = (this.team === 'blue') ? -50 : 750; destX = (this.x < 200) ? 100 : 300; }
        }

        if (!this.flying && !this.target) { 
            const isCrossing = (this.team === 'blue' && this.y > RIVER_Y_BOTTOM && destY < RIVER_Y_TOP) ||
                               (this.team === 'red' && this.y < RIVER_Y_TOP && destY > RIVER_Y_BOTTOM);
            if (isCrossing) {
                const distToLeft = Math.abs(this.x - 100); const distToRight = Math.abs(this.x - 300);
                destX = (distToLeft < distToRight) ? 100 : 300;
                if (Math.abs(this.x - destX) > 5) destY = this.y; 
                else destY = (this.team === 'blue') ? RIVER_Y_BOTTOM - 20 : RIVER_Y_TOP + 20; 
            }
        }

        const dx = destX - this.x; const dy = destY - this.y; const dist = Math.hypot(dx, dy);
        let moveX = 0, moveY = 0;
        if (dist > 1) { moveX = (dx / dist) * this.speed; moveY = (dy / dist) * this.speed; }

        for (let other of entities) {
            if (other === this || other.dead) continue;
            if (this.flying !== other.flying && other.typeIdx !== 'tower') continue;
            const dx2 = this.x - other.x; const dy2 = this.y - other.y;
            const d2 = Math.hypot(dx2, dy2); const minD = this.radius + other.radius;
            if (d2 < minD && d2 > 0.01) {
                const force = (minD - d2) * 5;
                moveX += (dx2 / d2) * force * 2; moveY += (dy2 / d2) * force * 2;
            }
        }
        this.x += moveX * dt; this.y += moveY * dt;
    }

    findTarget() {
        let bestTarget = null; let bestScore = Infinity; 
        for (const e of entities) {
            if (e.team === this.team || e.dead) continue;
            if (e.flying && !this.hitAir) continue;
            if (this.targetBuilding && e.type !== 'building') continue;

            // PRINCESS TOWER LANE LOGIC
            if (this.role === 'left_tower' && e.x > 220) continue; 
            if (this.role === 'right_tower' && e.x < 180) continue;

            const dist = Math.hypot(e.x - this.x, e.y - this.y);
            const isBuilding = (e.type === 'building' || e.typeIdx === 'tower');
            const isAggro = (dist < AGGRO_RANGE);
            if (isBuilding || isAggro) {
                let score = dist;
                if (isBuilding) score -= 50; 
                if (score < bestScore) { bestScore = score; bestTarget = e; }
            }
        }
        return bestTarget;
    }

    inRange(target) {
        if(!target) return false;
        const dist = Math.hypot(target.x - this.x, target.y - this.y);
        return dist <= this.range + target.radius;
    }

    attack(target) {
        if (this.projectile) {
            projectiles.push(new Projectile(this.x, this.y, target, this.dmg, this.color, this.splash, this.team));
        } else {
            target.takeDamage(this.dmg);
        }
    }

    draw() {
        if (isNaN(this.x)) return;
        
        if (this.typeIdx === 'tower') {
            drawTower(this);
            const hpPct = Math.max(0, this.hp / this.maxHp);
            ctx.fillStyle = '#222'; ctx.fillRect(this.x - 15, this.y - this.radius - 12, 30, 6);
            ctx.fillStyle = (this.team === 'blue') ? '#00ff00' : '#ff0000'; ctx.fillRect(this.x - 15, this.y - this.radius - 12, 30 * hpPct, 6);
            return;
        }

        if (this.type === 'building') {
            ctx.fillStyle = '#553311';
            ctx.fillRect(this.x - this.radius, this.y - this.radius, this.radius*2, this.radius*2);
            ctx.fillStyle = this.color;
            ctx.fillRect(this.x - this.radius + 4, this.y - this.radius + 4, this.radius*2 - 8, this.radius*2 - 8);
            ctx.strokeStyle = '#220000'; ctx.lineWidth = 2;
            ctx.strokeRect(this.x - this.radius, this.y - this.radius, this.radius*2, this.radius*2);
            if (this.frozenTimer > 0) {
                ctx.fillStyle = 'rgba(0, 255, 255, 0.5)';
                ctx.fillRect(this.x - this.radius, this.y - this.radius, this.radius*2, this.radius*2);
            }
        } else {
            if(!this.flying) {
                ctx.fillStyle = 'rgba(0,0,0,0.3)'; ctx.beginPath(); ctx.arc(this.x, this.y+5, this.radius, 0, Math.PI*2); ctx.fill();
            } else {
                ctx.fillStyle = 'rgba(0,0,0,0.2)'; ctx.beginPath(); ctx.arc(this.x, this.y+30, this.radius, 0, Math.PI*2); ctx.fill();
            }

            ctx.fillStyle = this.color;
            ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill();
            ctx.lineWidth = 1; ctx.strokeStyle = '#000'; ctx.stroke();

            const unitName = UNIT_TYPES[this.typeIdx].name;
            const facingUp = (this.team === 'blue');
            const dir = facingUp ? -1 : 1;

            if (unitName.includes('Goblin')) { 
                ctx.fillStyle = this.color; ctx.beginPath(); ctx.moveTo(this.x-5, this.y-5*dir); ctx.lineTo(this.x-12, this.y-10*dir); ctx.lineTo(this.x-5, this.y); ctx.fill();
                ctx.beginPath(); ctx.moveTo(this.x+5, this.y-5*dir); ctx.lineTo(this.x+12, this.y-10*dir); ctx.lineTo(this.x+5, this.y); ctx.fill();
            }
            if (unitName === 'PEKKA') { 
                ctx.fillStyle = '#538'; ctx.beginPath(); ctx.moveTo(this.x-6, this.y-6*dir); ctx.lineTo(this.x-14, this.y-14*dir); ctx.lineTo(this.x-2, this.y-8*dir); ctx.fill();
                ctx.beginPath(); ctx.moveTo(this.x+6, this.y-6*dir); ctx.lineTo(this.x+14, this.y-14*dir); ctx.lineTo(this.x+2, this.y-8*dir); ctx.fill();
            }
            if (unitName === 'Knight' || unitName === 'Barbarians') { 
                ctx.strokeStyle = '#ddd'; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(this.x+8, this.y); ctx.lineTo(this.x+18, this.y-10*dir); ctx.stroke();
            }
            if (unitName === 'Archers') { 
                ctx.strokeStyle = '#852'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(this.x+5, this.y, 8, 0, Math.PI*2); ctx.stroke();
            }
            if (unitName.includes('Recruit')) { 
                ctx.fillStyle = '#642'; ctx.fillRect(this.x-10, this.y + (facingUp ? -12 : 4), 20, 8);
            }
            if (unitName === 'Wizard') { 
                ctx.fillStyle = '#808'; ctx.beginPath(); ctx.moveTo(this.x, this.y-15*dir); ctx.lineTo(this.x-6, this.y); ctx.lineTo(this.x+6, this.y); ctx.fill();
            }

            if (this.frozenTimer > 0) {
                ctx.fillStyle = 'rgba(0, 255, 255, 0.5)';
                ctx.beginPath(); ctx.arc(this.x, this.y, this.radius+2, 0, Math.PI * 2); ctx.fill();
            }
        }

        const hpPct = Math.max(0, this.hp / this.maxHp);
        ctx.fillStyle = '#222'; ctx.fillRect(this.x - 10, this.y - this.radius - 8, 20, 4);
        ctx.fillStyle = (this.team === 'blue') ? '#00ff00' : '#ff0000'; ctx.fillRect(this.x - 10, this.y - this.radius - 8, 20 * hpPct, 4);
    }
}

class Projectile {
    constructor(x, y, target, dmg, color, splash, team, piercing = false, spawnUnitIdx = null) {
        this.x = x; this.y = y; this.target = target; this.dmg = dmg; this.color = color;
        this.splash = splash; this.team = team; this.speed = 450; this.dead = false;
        this.piercing = piercing; this.hitList = []; this.spawnUnitIdx = spawnUnitIdx;
        this.isSpell = (target instanceof Entity === false);
        this.destX = target.x; this.destY = target.y;
        if (dmg > 1000) this.speed = 250; 
        if (piercing) this.speed = 160; 
        if (spawnUnitIdx) this.speed = 200; 
        this.life = 2.0; 
    }
    update(dt) {
        if (!this.isSpell && this.target && !this.target.dead) { this.destX = this.target.x; this.destY = this.target.y; }
        let dx, dy;
        if (this.piercing) {
            dy = (this.team === 'blue' ? -1 : 1); dx = 0; this.life -= dt; if (this.life <= 0) this.dead = true;
        } else {
            dx = this.destX - this.x; dy = this.destY - this.y;
        }
        
        const dist = Math.hypot(dx, dy); 

        if (this.piercing) {
            this.x += dx * this.speed * dt; this.y += dy * this.speed * dt;
            entities.forEach(e => {
                if (e.team !== this.team && !e.dead && !e.flying) {
                    const d = Math.hypot(e.x - this.x, e.y - this.y);
                    if (d < 30 && !this.hitList.includes(e)) {
                        e.takeDamage(this.dmg); this.hitList.push(e); spawnParticle(e.x, e.y, '#8b4513', 3);
                    }
                }
            });
            return;
        }

        if (dist < 10) {
            if (this.spawnUnitIdx !== null) {
                if (this.spawnUnitIdx === 0) { // Goblin Barrel
                    entities.push(new Entity(this.x, this.y-15, this.team, 0));
                    entities.push(new Entity(this.x-15, this.y+10, this.team, 0));
                    entities.push(new Entity(this.x+15, this.y+10, this.team, 0));
                    spawnParticle(this.x, this.y, '#8b4513', 10);
                } else {
                    entities.push(new Entity(this.x, this.y, this.team, this.spawnUnitIdx));
                    entities.forEach(e => { if (e.team !== this.team && !e.dead) { const d = Math.hypot(e.x - this.x, e.y - this.y); if (d < 60) e.takeDamage(this.dmg); } });
                    spawnParticle(this.x, this.y, '#664422', 15);
                }
            } else if (this.dmg > 1000 && this.isSpell) { // Rocket
                spawnParticle(this.x, this.y, '#ff4400', 30);
                let bestTarget = null; let maxHp = -1;
                entities.forEach(e => { if (e.team !== this.team && !e.dead) { const d = Math.hypot(e.x - this.x, e.y - this.y); if (d < 60 && e.hp > maxHp) { maxHp = e.hp; bestTarget = e; } } });
                if (bestTarget) bestTarget.takeDamage((bestTarget.typeIdx === 'tower') ? 500 : 9999);
            } else if (this.splash || this.isSpell) {
                spawnParticle(this.x, this.y, this.color, 10);
                entities.forEach(e => { if (e.team !== this.team && !e.dead) { const d = Math.hypot(e.x - this.x, e.y - this.y); const radius = this.isSpell ? 60 : 60; if (d < radius) e.takeDamage(this.dmg); } });
            } else {
                if(this.target && !this.target.dead) this.target.takeDamage(this.dmg);
            }
            this.dead = true;
        } else {
            this.x += (dx/dist) * this.speed * dt; this.y += (dy/dist) * this.speed * dt;
        }
    }
    draw() {
        ctx.fillStyle = this.color; 
        ctx.shadowBlur = 10; ctx.shadowColor = this.color;
        if (this.piercing) {
            ctx.fillStyle = '#8b4513'; ctx.fillRect(this.x-15, this.y-10, 30, 20); ctx.fillStyle = '#654321'; ctx.fillRect(this.x-15, this.y-2, 30, 4);
        } else if (this.spawnUnitIdx === 0) { // Barrel
            ctx.fillStyle = '#654'; ctx.beginPath(); ctx.arc(this.x, this.y, 8, 0, Math.PI*2); ctx.fill(); ctx.strokeStyle = '#222'; ctx.lineWidth = 2; ctx.stroke();
        } else {
            ctx.beginPath(); const r = (this.dmg > 1000 || this.spawnUnitIdx) ? 10 : 6;
            ctx.arc(this.x, this.y, r, 0, Math.PI*2); ctx.fill();
        }
        ctx.shadowBlur = 0;
    }
}

class Particle {
    constructor(x, y, color) {
        this.x = x; this.y = y; this.color = color; this.life = 1.0;
        this.vx = (Math.random() - 0.5) * 80; this.vy = (Math.random() - 0.5) * 80;
    }
    update(dt) { this.x+=this.vx*dt; this.y+=this.vy*dt; this.life-=dt*2; }
    draw() {
        ctx.globalAlpha = Math.max(0, this.life); ctx.fillStyle = this.color;
        ctx.beginPath(); ctx.arc(this.x,this.y,3,0,Math.PI*2); ctx.fill(); ctx.globalAlpha = 1.0;
    }
}
function spawnParticle(x, y, color, c) { for(let i=0; i<c; i++) particles.push(new Particle(x, y, color)); }

function shuffle(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
}

function startGame() { if (playerDeck.length !== 8) { alert("You must edit your deck and select exactly 8 cards!"); return; } document.getElementById('main-menu').style.display = 'none'; document.getElementById('ui-container').style.display = 'flex'; resetGame(); }
function goToMenu() { document.getElementById('end-screen').style.display = 'none'; document.getElementById('ui-container').style.display = 'none'; document.getElementById('main-menu').style.display = 'flex'; gameState = 'MENU'; }
function resetGame() {
    gameState = 'PLAYING'; gameTime = 0; entities = []; projectiles = []; particles = [];
    player = { elixir: 5, team: 'blue' }; enemy = { elixir: 5, team: 'red', nextCard: null, waitTime: 0 };
    leftEnemyTowerDead = false; rightEnemyTowerDead = false; selectedHandIndex = null; lastPlayedCardIdx = null; overtimeTriggered = false;
    document.getElementById('end-screen').style.display = 'none';
    deckQueue = [...playerDeck]; shuffle(deckQueue); hand = deckQueue.splice(0, 4); renderDeck();
    entities.push(new Entity(100, 520, 'blue', 'tower', 'left_tower')); entities.push(new Entity(300, 520, 'blue', 'tower', 'right_tower')); entities.push(new Entity(200, 670, 'blue', 'tower', 'king'));
    entities.push(new Entity(100, 150, 'red', 'tower', 'left_tower')); entities.push(new Entity(300, 150, 'red', 'tower', 'right_tower')); entities.push(new Entity(200, 30, 'red', 'tower', 'king'));
}

function renderDeck() {
    const handDiv = document.getElementById('hand'); handDiv.innerHTML = '';
    hand.forEach((uIdx, i) => {
        let u = UNIT_TYPES[uIdx]; let realCost = u.cost; let displayName = u.name; let isMirror = (u.name === 'Mirror'); let isDisabled = false;
        if (isMirror) {
            if (lastPlayedCardIdx !== null) { const targetUnit = UNIT_TYPES[lastPlayedCardIdx]; realCost = targetUnit.cost + 1; displayName = "Mirror " + targetUnit.name; } 
            else { displayName = "Mirror (?)"; realCost = "?"; isDisabled = true; }
        }
        const isSel = (i === selectedHandIndex); const classes = `card ${isSel ? 'selected' : ''} ${isMirror ? 'mirror-card' : ''} ${isDisabled ? 'disabled' : ''}`;
        handDiv.innerHTML += `<div class="${classes}" onclick="onCardClick(${i})"><div class="card-icon" style="background:${u.color}"></div><h3>${displayName}</h3><div class="card-type">${u.type}</div><p>${realCost}</p></div>`;
    });
    const nextIdx = deckQueue[0]; const uNext = UNIT_TYPES[nextIdx];
    document.getElementById('next-card-container').innerHTML = `<div class="card" style="transform: scale(0.8); cursor: default; box-shadow:none; border-color:#444;"><div class="card-icon" style="background:${uNext.color}"></div><h3 style="font-size:10px">${uNext.name}</h3><p style="font-size:10px">${uNext.cost}</p></div>`;
}

window.onCardClick = function(i) { const uIdx = hand[i]; if (UNIT_TYPES[uIdx].name === 'Mirror' && lastPlayedCardIdx === null) return; selectedHandIndex = (selectedHandIndex === i) ? null : i; renderDeck(); }

function castSpell(typeIdx, x, y, team) {
    const stats = UNIT_TYPES[typeIdx];
    if (stats.name === 'Fireball' || stats.name === 'Rocket') {
        const king = entities.find(e => e.team === team && e.role === 'king');
        const startX = king ? king.x : 200; const startY = king ? king.y : (team === 'blue' ? 700 : 0);
        projectiles.push(new Projectile(startX, startY, {x:x, y:y}, stats.dmg, stats.color, true, team));
    } else if (stats.name === 'Royal Delivery') {
        const king = entities.find(e => e.team === team && e.role === 'king');
        const startX = king ? king.x : 200; const startY = king ? king.y : (team === 'blue' ? 700 : 0);
        projectiles.push(new Projectile(startX, startY, {x:x, y:y}, stats.dmg, stats.color, true, team, false, stats.spawnUnit));
    } else if (stats.name === 'Goblin Barrel') {
        const king = entities.find(e => e.team === team && e.role === 'king');
        const startX = king ? king.x : 200; const startY = king ? king.y : (team === 'blue' ? 700 : 0);
        projectiles.push(new Projectile(startX, startY, {x:x, y:y}, 0, stats.color, false, team, false, 0));
    } else if (stats.name === 'Zap') {
        spawnParticle(x, y, '#00ffff', 15);
        entities.forEach(e => { if (e.team !== team && !e.dead) { const dist = Math.hypot(e.x - x, e.y - y); if (dist < stats.radius) e.takeDamage(stats.dmg); } });
    } else if (stats.name === 'The Log') {
        projectiles.push(new Projectile(x, y, {x:x, y:y}, stats.dmg, stats.color, false, team, true));
    } else if (stats.name === 'Freeze') {
        spawnParticle(x, y, '#aaddff', 15);
        entities.forEach(e => { if (e.team !== team && !e.dead) { const dist = Math.hypot(e.x - x, e.y - y); if (dist < stats.radius) { e.frozenTimer = 4.0; e.takeDamage(stats.dmg); } } });
    }
}

function isValidSpawn(x, y, isDelivery = false) {
    for(let e of entities) { if (!e.dead && (e.typeIdx === 'tower' || e.type === 'building')) { const d = Math.hypot(e.x - x, e.y - y); if (d < e.radius + 10) return false; } }
    if (isDelivery) { if (y < RIVER_Y_BOTTOM) return false; }
    if (y > RIVER_Y_BOTTOM) return true;
    if (leftEnemyTowerDead) { if (x < 200 && y > 250) return true; }
    if (rightEnemyTowerDead) { if (x > 200 && y > 250) return true; }
    return false;
}

function handleInputStart(x, y) {
    if (gameState !== 'PLAYING' || selectedHandIndex === null) return;
    
    let unitIdx = hand[selectedHandIndex]; let unitData = UNIT_TYPES[unitIdx]; let realCost = unitData.cost;
    
    if (unitData.name === 'Mirror') { if (lastPlayedCardIdx === null) return; unitIdx = lastPlayedCardIdx; unitData = UNIT_TYPES[unitIdx]; realCost = unitData.cost + 1; }
    if (player.elixir < realCost) return;

    const isDelivery = (unitData.name === 'Royal Delivery' || unitData.name === 'The Log');
    if (!isValidSpawn(x, y, isDelivery) && unitData.type !== 'spell') { const err = document.getElementById('errorZone'); err.style.display = 'block'; setTimeout(() => err.style.display = 'none', 200); return; }
    if (isDelivery && !isValidSpawn(x, y, true)) { const err = document.getElementById('errorZone'); err.style.display = 'block'; setTimeout(() => err.style.display = 'none', 200); return; }

    if (unitData.type === 'spell') {
        player.elixir -= realCost; castSpell(unitIdx, x, y, 'blue');
        deckQueue.push(hand[selectedHandIndex]); hand[selectedHandIndex] = deckQueue.shift();
        lastPlayedCardIdx = unitIdx; selectedHandIndex = null; renderDeck(); return;
    }

    player.elixir -= realCost;
    const count = unitData.count || 1; const formation = unitData.formation || 'random';
    for(let i=0; i<count; i++) {
        let ox = 0, oy = 0;
        if (formation === 'line') { ox = (i - (count-1)/2) * 20; oy = 0; } else { ox = (Math.random() - 0.5) * 30; oy = (Math.random() - 0.5) * 30; }
        entities.push(new Entity(x + ox, y + oy, 'blue', unitIdx));
    }
    
    deckQueue.push(hand[selectedHandIndex]); hand[selectedHandIndex] = deckQueue.shift();
    lastPlayedCardIdx = unitIdx; selectedHandIndex = null; renderDeck();
}


function updateAI(dt) {
    if (gameState !== 'PLAYING') return;
    let pumpCount = entities.filter(e => e.team === 'red' && e.typeIdx === PUMP_INDEX).length;
    let baseRate = (gameTime >= DOUBLE_ELIXIR_TIME) ? ELIXIR_RATE * 2 : ELIXIR_RATE;
    let totalRate = baseRate + (pumpCount * ELIXIR_RATE);
    
    enemy.elixir += totalRate * dt;
    if (enemy.elixir > MAX_ELIXIR) enemy.elixir = MAX_ELIXIR;
    
    if (enemy.nextCard === null) { enemy.nextCard = DRAFTABLE_INDICES[Math.floor(Math.random() * DRAFTABLE_INDICES.length)]; if(UNIT_TYPES[enemy.nextCard].name === 'Mirror') enemy.nextCard = 1; enemy.waitTime = 0; }
    const u = UNIT_TYPES[enemy.nextCard]; if (!u) { enemy.nextCard = null; return; }

    if (enemy.elixir >= u.cost) {
        enemy.waitTime += dt;
        if (enemy.waitTime > 1.0) {
            enemy.elixir -= u.cost;
            if (u.type === 'spell') {
                const blueTargets = entities.filter(e => e.team === 'blue');
                if (blueTargets.length > 0) { const target = blueTargets[Math.floor(Math.random() * blueTargets.length)]; castSpell(enemy.nextCard, target.x, target.y, 'red'); }
            } else {
                const laneX = Math.random() > 0.5 ? 100 : 300; const spawnY = 120 + Math.random() * 60; const count = u.count || 1;
                for(let i=0; i<count; i++) { const ox = (Math.random() - 0.5) * 30; entities.push(new Entity(laneX + ox, spawnY, 'red', enemy.nextCard)); }
            }
            enemy.nextCard = null;
        }
    }
}

function countDeadTowers(team) {
    let dead = 0;
    // King death is immediate game over, so check Side Towers only for tie-breaker
    const left = entities.find(e => e.team === team && e.role === 'left_tower');
    const right = entities.find(e => e.team === team && e.role === 'right_tower');
    if (!left || left.dead) dead++;
    if (!right || right.dead) dead++;
    return dead;
}

function getLowestTowerHP(team) {
    let minHP = Infinity;
    entities.forEach(e => {
        if (e.team === team && e.typeIdx === 'tower' && !e.dead) {
            if (e.hp < minHP) minHP = e.hp;
        }
    });
    if (minHP === Infinity) return 0; // All dead
    return minHP;
}

function checkWin(loserTeam) {
    gameState = 'GAMEOVER'; const screen = document.getElementById('end-screen'); const msg = document.getElementById('end-message');
    screen.style.display = 'flex'; if (loserTeam === 'red') { msg.innerText = "BLUE WINS!"; msg.style.color = '#4488ff'; } else { msg.innerText = "RED WINS!"; msg.style.color = '#ff4444'; }
}

function checkTimeRules() {
    // 3 Minute Check
    if (!overtimeTriggered && gameTime >= TIME_LIMIT_NORMAL) {
        overtimeTriggered = true;
        const blueDead = countDeadTowers('blue');
        const redDead = countDeadTowers('red');
        if (blueDead > redDead) checkWin('blue');
        else if (redDead > blueDead) checkWin('red');
        // else continue to Sudden Death
    }

    // 5 Minute Check (Hard Stop)
    if (gameTime >= TIME_LIMIT_MAX) {
        const blueHP = getLowestTowerHP('blue');
        const redHP = getLowestTowerHP('red');
        if (blueHP < redHP) checkWin('blue');
        else checkWin('red'); // If equal, red wins (arbitrary)
    }
}

function gameLoop(timestamp) {
    safeLoop(() => {
        let dt = (timestamp - lastTime) / 1000; lastTime = timestamp; if (dt > 0.5) dt = 0.016; 

        if (gameState === 'PLAYING') {
            gameTime += dt;
            checkTimeRules();

            let pumpCount = entities.filter(e => e.team === 'blue' && e.typeIdx === PUMP_INDEX).length;
            let baseRate = (gameTime >= DOUBLE_ELIXIR_TIME) ? ELIXIR_RATE * 2 : ELIXIR_RATE;
            let totalRate = baseRate + (pumpCount * ELIXIR_RATE);
            
            player.elixir += totalRate * dt;
            if (player.elixir > MAX_ELIXIR) player.elixir = MAX_ELIXIR;
            
            document.getElementById('elixirText').innerText = Math.floor(player.elixir);
            const fill = document.getElementById('elixirFill');
            fill.style.width = (player.elixir / MAX_ELIXIR * 100) + '%';
            if (pumpCount > 0) fill.classList.add('boosted'); else fill.classList.remove('boosted');
            if (gameTime >= DOUBLE_ELIXIR_TIME) fill.classList.add('double-elixir');
            
            updateAI(dt);
            entities.forEach(e => e.update(dt));
            projectiles.forEach(p => p.update(dt));
            particles.forEach(p => p.update(dt));
            entities = entities.filter(e => !e.dead);
            projectiles = projectiles.filter(p => !p.dead);
            particles = particles.filter(p => p.life > 0);
        }

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawMap();
        
        // Draw Timer
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 20px sans-serif';
        ctx.textAlign = 'center';
        const minutes = Math.floor(gameTime / 60);
        const seconds = Math.floor(gameTime % 60);
        const timeStr = minutes + ":" + (seconds < 10 ? "0" : "") + seconds;
        ctx.fillText(timeStr, 200, 30);

        if (gameState === 'PLAYING' && gameTime >= DOUBLE_ELIXIR_TIME) {
            ctx.fillStyle = 'rgba(255, 0, 255, 0.5)';
            ctx.font = 'bold 30px sans-serif';
            ctx.textAlign = 'right';
            ctx.fillText("2x", 380, 40);
        }

        if (gameState === 'PLAYING' && selectedHandIndex !== null) {
            let uIdx = hand[selectedHandIndex]; let u = UNIT_TYPES[uIdx];
            if (u.name === 'Mirror' && lastPlayedCardIdx !== null) u = UNIT_TYPES[lastPlayedCardIdx];

            if (u.type === 'spell') {
                if(u.name === 'The Log') {
                    // Log Preview
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                    ctx.fillRect(mouseX - 15, mouseY - 250, 30, 250); 
                } else if (u.name !== 'Royal Delivery') {
                    ctx.fillStyle = 'rgba(255, 200, 0, 0.1)'; ctx.fillRect(0,0,400,700);
                }
            } 
            
            if (u.type !== 'spell' || u.name === 'Royal Delivery' || u.name === 'The Log') {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                if (leftEnemyTowerDead) ctx.fillRect(0, 250, 200, RIVER_Y_TOP - 250);
                if (rightEnemyTowerDead) ctx.fillRect(200, 250, 200, RIVER_Y_TOP - 250);
                ctx.setLineDash([5, 5]); ctx.strokeStyle = 'rgba(255,255,255,0.4)'; ctx.beginPath();
                ctx.moveTo(0, RIVER_Y_BOTTOM); ctx.lineTo(400, RIVER_Y_BOTTOM); ctx.stroke(); ctx.setLineDash([]);
            }
        }

        const ground = entities.filter(e => !e.flying);
        const air = entities.filter(e => e.flying);
        ground.sort((a, b) => a.y - b.y);
        air.sort((a, b) => a.y - b.y);

        ground.forEach(e => e.draw());
        air.forEach(e => e.draw());
        projectiles.forEach(p => p.draw());
        particles.forEach(p => p.draw());
    });
    requestAnimationFrame(gameLoop);
}

drawMap();
requestAnimationFrame(gameLoop);

</script>
</body>
</html>